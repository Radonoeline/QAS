<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QAS Utilitaire</title>
    <style>
        /* Styles de base pour les onglets */
        .multipage {
            display: flex;
            flex-direction: column;
            width: auto;
            margin: 0 auto;
        }

        .tab-buttons {
            display: flex;
        }

        .tab-button {
            flex: 1;
            padding: 10px;
            cursor: pointer;
            background-color: lightgray;
            text-align: center;
            border: 1px solid #ccc;
        }

        .tab-button.active {
            background-color: white;
            border-bottom: 1px solid white;
            font-weight: bold;
        }

        .page-content {
            border: 1px solid #ccc;
            padding: 20px;
            display: none;
        }

        .page-content.active {
            display: block;
        }
    </style>
	<script src="papaparse_rado.js"></script>
    <link rel="stylesheet" href="styles.css">
	 <style>
        .file-input {
            display: block;
            margin-bottom: 20px;
        }
    </style>
    <style>
        body {
            font-family: Arial, sans-serif;
        }
        header {
            position: fixed;
            top: 0;
            width: 100%;
            background-color: #f8f8f8;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            z-index: 1000;
        }
        h1 {
            margin: 0;
            font-size: 24px;
        }
        .file-input-label {
            margin-right: 10px;
            font-size: 12px;
        }
        .options-container {
            margin-top: 10px;
            font-size: 12px;
        }
        .options-container button,
        .options-container label,
        .options-container input[type="radio"] {
            font-size: inherit;
            margin-right: 10px;
            margin-top: 5px;
        }
        .file-input {
            display: inline-block;
            margin-right: 20px;
            font-size: 12px;
        }
        .main-content {
            margin-top: 50px; /* Adjust this value to ensure the main content is not hidden */
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        table, th, td {
            border: 1px solid #ccc;
        }
        th, td {
            padding: 8px;
            text-align: left;
        }
		.page-content {
			border: 1px solid #ccc;
			padding: 75px;
			display: none;
			margin-left: none;  /* Marge à gauche */
			margin-right: none; /* Marge à droite */
		}
    </style>
</head>
<body>

    <header><div class="multipage">
        <div class="tab-buttons">
            <div class="tab-button active" onclick="showPage('page1')">Monthly/Daily Report: Dynamic Table Generation</div>
            <div class="tab-button" onclick="showPage('page2')">Worker Performance and Error Report</div>
            <div class="tab-button" onclick="showPage('page3')">Page 3</div>
        </div>
	</header>
        <div id="page1" class="page-content active">
        <h1>Monthly/Daily Report: Dynamic Table Generation</h1>
        <div id="safidy" style="background-color: black; color: white; padding: 10px; border-radius: 5px;">
		<label for="dataType">Choisissez le type de données :</label>
		<select id="dataType">
			<option value="tsv_journalier">Fichier TSV Journalier (Details ASIN)</option>
			<option value="tsv_mensuel">Fichier TSV Mensuel (Output Lockers)</option>
		</select><br><br>
		<label for="indexType">Index pour le CRJ:</label>
		<select id="indextype">
			<option value="AIN-LMR-CBUI">AIN-LMR-CBUI</option>
			<option value="AIN-LMR-FBUI">AIN-LMR-FBUI</option>
			<option value="AIN-LMR-CODE-P">AIN-LMR-CODE-P</option>
			<option value="AIN-LMR-COUI">AIN-LMR-COUI</option>
			<option value="AIN-LMR-FOUI-P">AIN-LMR-FOUI-P</option>
			<option value="AIN-LMR-LBUI-P">AIN-LMR-LBUI-P</option>
			<option value="AIN-LMR-CAUI">AIN-LMR-CAUI</option>
			<option value="AIN-LMR-CBU2">AIN-LMR-CBU2</option>
			<option value="AIN-LMR-FAUI-P">AIN-LMR-FAUI-P</option>
		</select>
		</div>

		<div id="fileInputa">
        <input type="file" id="fileInput" class="file-input" accept=".tsv">
		<button onclick="DetailedAttributConsensus()">Detailed Consensus Attribute</button>
            <button onclick="calculateConsensusWorker()">Detailed Consensus WorkerID</button>
            <button onclick="calculateAccuracyWorkerID()">Accuracy WorkerID</button>
            <button onclick="executeBoth()">Agreement / Summary</button>
			<button id="extract_data">Extraction CRJ</button>
		</div>

    <div class="main-content" id="result">
    <div class="table-pair">
        <table id="CRJ_Table1">
            <tr>
                <th>Assignment échantillonné</th>
                <th>Taux d'erreurs</th>
                <th>Assignment KO</th>
                <th>Détail</th>
            </tr>
        </table>

        <table id="CRJ_Table2">
            <tr>
                <th>HIT contrôlé</th>
                <th>HIT KO</th>
                <th>CORRECT_MAJORITY</th>
                <th>CORRECT_MINORITY</th>
                <th>INCORRECT_MAJORITY</th>
                <th>INCORRECT_MINORITY</th>
            </tr>
        </table>
    </div>

    <div class="table-pair">
        <table id="agreementTable"></table>
        <table id="summaryTable"></table>
    </div>

    <table id="accuracyWorkerID"></table>
    <table id="consensusWorkerID"></table>
    <table id="consensusAttributDetailed"></table>
    <table id="resultTable"></table>
</div>
        </div>

        <div id="page2" class="page-content">
		<div id="controls">
        <input type="file" id="csvFileInput" accept=".tsv" />
			<button onclick="executeAllFunctions()">GENERATE 10 TOPS</button>
        </div>
	<table id="resultsTopCMaj"></table>
	<table id="resultsTopCMin"></table>
	<table id="resultsTopIMaj"></table>
	<table id="resultsTopIMin"></table>
    <table id="resultstable"></table>
        </div>

        <div id="page3" class="page-content">
            <h2>Contenu de la Page 3</h2>
            <p>Ceci est le contenu de la troisième page.</p>
        </div>
    </div>

    <script>
        function showPage(pageId) {
            // Masquer toutes les pages
            var pages = document.querySelectorAll('.page-content');
            pages.forEach(function(page) {
                page.classList.remove('active');
            });

            // Désactiver tous les boutons
            var buttons = document.querySelectorAll('.tab-button');
            buttons.forEach(function(button) {
                button.classList.remove('active');
            });

            // Afficher la page sélectionnée
            document.getElementById(pageId).classList.add('active');

            // Activer le bouton correspondant
            event.currentTarget.classList.add('active');
        }
		
	
	 document.getElementById('dataType').addEventListener('change', function () {
            const fileInput = document.getElementById('fileInput');

            fileInput.value = ''; // Reset file input value
        });

        document.getElementById('fileInput').addEventListener('change', function (event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function (e) {
                    const content = e.target.result;
                    const selectedType = document.getElementById('dataType').value;

                    if (selectedType === 'tsv_journalier') {
                         processDataDaily(content);
                        console.log('Traitement du fichier TSV journalier');
                    } else if (selectedType === 'tsv_mensuel') {
                        processData(content);
                    }
                };
                reader.readAsText(file);
            }
        });
		
		
	function processDataDaily(data) {
    Papa.parse(data, {
        header: true,
        delimiter: '\t',
        skipEmptyLines: true,
        preview: 500000,
        complete: function (results) {
            const parsedData = results.data;
            const necessaryHeaders = ['hitid', 'AssignmentId', 'workerid', 'key', 'assin_json', 'assin_juge_json'];
            const headersFromData = results.meta.fields.map(header => header.trim().toLowerCase());
            const normalizedNecessaryHeaders = necessaryHeaders.map(header => header.trim().toLowerCase());
            const headersPresent = normalizedNecessaryHeaders.every(header => headersFromData.includes(header));

            if (!headersPresent) {
                console.error('Headers found:', headersFromData);
                console.error('Expected headers:', normalizedNecessaryHeaders);
                alert('Les entêtes nécessaires ne sont pas toutes présentes.');
                return;
            }

            const resultTable = document.getElementById('resultTable');
            resultTable.innerHTML = '';

            const caption = resultTable.createCaption();
            caption.textContent = 'ANALYSE GLOBAL DES RESULTATS VENANT DE LOOKERS STUDIO';

            const headers = necessaryHeaders.concat(['smarter', 'juge']);
            const headerRow = resultTable.insertRow();

            headers.forEach(header => {
                const cell = document.createElement('th');
                cell.textContent = header;
                headerRow.appendChild(cell);
            });

            const uniqueKeys = new Set();
            parsedData.forEach(row => {
                const assinJson = row.assin_json.split(',');
                const jugeJson = row.assin_juge_json.split(',');

                assinJson.forEach(key => uniqueKeys.add(key.trim()));
                jugeJson.forEach(key => uniqueKeys.add(key.trim()));

                row.smarter = assinJson.join(',');
                row.juge = jugeJson.join(',');
            });

            uniqueKeys.forEach(key => {
                if (key) {
                    const cell = document.createElement('th');
                    cell.textContent = key;
                    headerRow.appendChild(cell);
                }
            });

            const asinJudgmentHeader = document.createElement('th');
            asinJudgmentHeader.textContent = 'Jugement ASIN';
            headerRow.appendChild(asinJudgmentHeader);

            const assignmentJudgmentHeader = document.createElement('th');
            assignmentJudgmentHeader.textContent = 'Jugement Assignement';
            headerRow.appendChild(assignmentJudgmentHeader);

            const hitJudgmentHeader = document.createElement('th');
            hitJudgmentHeader.textContent = 'Jugement HitId';
            headerRow.appendChild(hitJudgmentHeader);

            parsedData.forEach(row => {
                const rowElement = resultTable.insertRow();
                headers.forEach(header => {
                    const cell = rowElement.insertCell();
                    cell.textContent = row[header] || '';
                });

                uniqueKeys.forEach(key => {
                    const cell = rowElement.insertCell();
                    cell.textContent = '';
                });

                const asinJudgmentCell = rowElement.insertCell();
                asinJudgmentCell.textContent = '';

                const assignmentJudgmentCell = rowElement.insertCell();
                assignmentJudgmentCell.textContent = '';

                const hitJudgmentCell = rowElement.insertCell();
                hitJudgmentCell.textContent = '';
            });

            // Regrouper par `key` et `AssignmentId`
            const groupedByKey = parsedData.reduce((acc, row, index) => {
                if (!acc[row.key]) acc[row.key] = [];
                row.index = index;
                acc[row.key].push(row);
                return acc;
            }, {});

            const groupedByAssignment = parsedData.reduce((acc, row) => {
                if (!acc[row.AssignmentId]) acc[row.AssignmentId] = [];
                acc[row.AssignmentId].push(row);
                return acc;
            }, {});

            const groupedByHit = parsedData.reduce((acc, row) => {
                if (!acc[row.hitid]) acc[row.hitid] = [];
                acc[row.hitid].push(row);
                return acc;
            }, {});

            Object.keys(groupedByKey).forEach(key => {
                const group = groupedByKey[key];
                const totalRows = group.length;

                const smarterCounts = {};
                const jugeCounts = {};

                group.forEach(row => {
                    row.smarter.split(', ').forEach(attr => {
                        if (attr) smarterCounts[attr] = (smarterCounts[attr] || 0) + 1;
                    });
                    row.juge.split(', ').forEach(attr => {
                        if (attr) jugeCounts[attr] = (jugeCounts[attr] || 0) + 1;
                    });
                });

                group.forEach(row => {
                    const rowIndex = row.index;
                    const rowElement = resultTable.rows[rowIndex + 1];

                    uniqueKeys.forEach(attr => {
                        let cellValue = '';
                        const smarterHasAttr = row.smarter.includes(attr);
                        const jugeHasAttr = row.juge.includes(attr);
                        const countSmarterCorrect = group.filter(r => r.smarter.includes(attr) && r.juge.includes(attr)).length;
                        const countSmarterIncorrect = group.filter(r => r.smarter.includes(attr) && !r.juge.includes(attr)).length;
                        const countMissing = group.filter(r => !r.smarter.includes(attr) && r.juge.includes(attr)).length;

                        if (smarterHasAttr && jugeHasAttr) {
                            cellValue = countSmarterCorrect >= totalRows / 2 ? 'c_maj' : 'c_min';
                        } else if (smarterHasAttr && !jugeHasAttr) {
                            cellValue = countSmarterIncorrect >= totalRows / 2 ? 'i_maj' : 'i_min';
                        } else if (!smarterHasAttr && jugeHasAttr) {
                            cellValue = countMissing >= totalRows / 2 ? 'missing_maj' : 'missing_min';
                        }

                        const cell = rowElement.cells[Array.from(headerRow.cells).findIndex(c => c.textContent === attr)];
                        if (cell) {
                            cell.textContent = cellValue;
                        }
                    });

                    const asinJudgmentIndex = Array.from(headerRow.cells).findIndex(c => c.textContent === 'Jugement ASIN');
                    const asinJudgmentCell = rowElement.cells[asinJudgmentIndex];
                    const cellValues = Array.from(rowElement.cells).slice(headers.length, headers.length + uniqueKeys.size).map(cell => cell.textContent);

                    if (cellValues.includes('i_min') || cellValues.includes('i_maj') || cellValues.includes('missing_min') || cellValues.includes('missing_maj')) {
                        asinJudgmentCell.textContent = 'ko';
                    } else if ((cellValues.includes('c_min') || cellValues.includes('c_maj')) &&
                        !cellValues.includes('i_min') && !cellValues.includes('i_maj') &&
                        !cellValues.includes('missing_min') && !cellValues.includes('missing_maj')) {
                        asinJudgmentCell.textContent = 'ok';
                    }
                });
            });

            // Calcul de "Jugement Assignement"
            Object.keys(groupedByAssignment).forEach(assignmentId => {
                const assignmentGroup = groupedByAssignment[assignmentId];
                const totalCount = assignmentGroup.length;
                const okCount = assignmentGroup.filter(row => {
                    const rowIndex = row.index;
                    const rowElement = resultTable.rows[rowIndex + 1];
                    const asinJudgmentIndex = Array.from(headerRow.cells).findIndex(c => c.textContent === 'Jugement ASIN');
                    const asinJudgmentCell = rowElement.cells[asinJudgmentIndex];
                    return asinJudgmentCell.textContent === 'ok';
                }).length;

                const assignmentJudgmentRatio = okCount / totalCount;
                const assignmentJudgment = assignmentJudgmentRatio > 0.5 ? 'assignement_ok' : 'assignement_ko';

                assignmentGroup.forEach(row => {
                    const rowIndex = row.index;
                    const rowElement = resultTable.rows[rowIndex + 1];
                    const assignmentJudgmentCell = rowElement.cells[Array.from(headerRow.cells).findIndex(c => c.textContent === 'Jugement Assignement')];
                    assignmentJudgmentCell.textContent = assignmentJudgment;
                });
            });

           // Calcul de "Jugement HitId"
			Object.keys(groupedByHit).forEach(hitid => {
				const hitGroup = groupedByHit[hitid]; // Groupe des lignes pour ce hitid
				const totalCount = hitGroup.length; // Nombre total de lignes pour ce hitid
				const okCount = hitGroup.filter(row => {
					const rowIndex = row.index;
					const rowElement = resultTable.rows[rowIndex + 1];
					const assignmentJudgmentIndex = Array.from(headerRow.cells).findIndex(c => c.textContent === 'Jugement Assignement');
					const assignmentJudgmentCell = rowElement.cells[assignmentJudgmentIndex];
					return assignmentJudgmentCell.textContent === 'assignement_ok'; // Filtrer pour 'assignement_ok'
				}).length; // Nombre de 'assignement_ok'

				const hitJudgmentRatio = okCount / totalCount; // Calcul du ratio

				// Déterminer le jugement basé sur le ratio
				const hitJudgment = hitJudgmentRatio > 0.5 ? 'hitid_ok' : 'hitid_ko';

				// Mettre à jour toutes les lignes avec le jugement déterminé
				hitGroup.forEach(row => {
					const rowIndex = row.index;
					const rowElement = resultTable.rows[rowIndex + 1];
					const hitJudgmentCell = rowElement.cells[Array.from(headerRow.cells).findIndex(c => c.textContent === 'Jugement HitId')];
					hitJudgmentCell.textContent = hitJudgment; // Mettre à jour avec 'hitid_ok' ou 'hitid_ko'
				});
			});


			// APPELLE A LA NOUVELLE PROCEDURE DE CALCUL CRJ


        }
    });
}











		
		
		// PROCESS DATA MONTHLY REPORTING ITO
function processData(data) {
    Papa.parse(data, {
        header: true,
        delimiter: '\t',
        skipEmptyLines: true,
        preview: 500000,
        complete: function (results) {
            const parsedData = results.data;
            const necessaryHeaders = ['hitid', 'workerid', 'key', 'assin_json', 'assin_juge_json'];
            console.log(results.data);
            console.log(results.errors);

            const headersFromData = results.meta.fields.map(header => header.trim().toLowerCase());
            const normalizedNecessaryHeaders = necessaryHeaders.map(header => header.trim().toLowerCase());
            const headersPresent = normalizedNecessaryHeaders.every(header => headersFromData.includes(header));

            if (!headersPresent) {
                console.error('Headers found:', headersFromData);
                console.error('Expected headers:', normalizedNecessaryHeaders);
                alert('Les entêtes nécessaires ne sont pas toutes présentes.');
                return;
            }

            const invalidJson = parsedData.some(row => {
                try {
                    JSON.parse(row.assin_json);
                    JSON.parse(row.assin_juge_json);
                    return false;
                } catch {
                    return true;
                }
            });

            if (invalidJson) {
                alert('Certaines données JSON sont invalides.');
                return;
            }

            const resultTable = document.getElementById('resultTable');
            resultTable.innerHTML = '';

            const caption = resultTable.createCaption();
            caption.textContent = 'ANALYSE GLOBAL DES RESULTATS VENANT DE LOOKERS STUDIO';

            const headers = necessaryHeaders.concat(['smarter', 'juge']);
            const headerRow = resultTable.insertRow();

            headers.forEach(header => {
                const cell = document.createElement('th');
                cell.textContent = header;
                headerRow.appendChild(cell);
            });

            const uniqueKeys = new Set();
            parsedData.forEach(row => {
                const assinJson = JSON.parse(row.assin_json);
                const jugeJson = JSON.parse(row.assin_juge_json);

                Object.keys(assinJson).forEach(key => {
                    if (key !== 'purchase_availability') uniqueKeys.add(key);
                });
                Object.keys(jugeJson).forEach(key => {
                    if (key !== 'purchase_availability') uniqueKeys.add(key);
                });

                row.smarter = Object.keys(assinJson)
                    .filter(key => assinJson[key] && key !== 'purchase_availability')
                    .join(', ');
                row.juge = Object.keys(jugeJson)
                    .filter(key => jugeJson[key] && key !== 'purchase_availability')
                    .join(', ');
            });

            uniqueKeys.forEach(key => {
                const cell = document.createElement('th');
                cell.textContent = key;
                headerRow.appendChild(cell);
            });

            const asinJudgmentHeader = document.createElement('th');
            asinJudgmentHeader.textContent = 'Jugement ASIN';
            headerRow.appendChild(asinJudgmentHeader);

            const assignmentJudgmentHeader = document.createElement('th');
            assignmentJudgmentHeader.textContent = 'Jugement Assignement';
            headerRow.appendChild(assignmentJudgmentHeader);

            parsedData.forEach(row => {
                const rowElement = resultTable.insertRow();
                headers.forEach(header => {
                    const cell = rowElement.insertCell();
                    cell.textContent = row[header] || '';
                });

                uniqueKeys.forEach(key => {
                    const cell = rowElement.insertCell();
                    cell.textContent = '';
                });

                const asinJudgmentCell = rowElement.insertCell();
                asinJudgmentCell.textContent = '';

                const assignmentJudgmentCell = rowElement.insertCell();
                assignmentJudgmentCell.textContent = ''; // Cette cellule restera vide
            });

            const groupedByKey = parsedData.reduce((acc, row, index) => {
                if (!acc[row.key]) acc[row.key] = [];
                row.index = index;
                acc[row.key].push(row);
                return acc;
            }, {});

            Object.keys(groupedByKey).forEach(key => {
                const group = groupedByKey[key];
                const totalRows = group.length;

                const smarterCounts = {};
                const jugeCounts = {};

                group.forEach(row => {
                    row.smarter.split(', ').forEach(attr => {
                        if (attr) smarterCounts[attr] = (smarterCounts[attr] || 0) + 1;
                    });
                    row.juge.split(', ').forEach(attr => {
                        if (attr) jugeCounts[attr] = (jugeCounts[attr] || 0) + 1;
                    });
                });

                group.forEach(row => {
                    const rowIndex = row.index;
                    const rowElement = resultTable.rows[rowIndex + 1];

                    uniqueKeys.forEach(attr => {
                        let cellValue = '';
                        const smarterHasAttr = row.smarter.includes(attr);
                        const jugeHasAttr = row.juge.includes(attr);
                        const countSmarterCorrect = group.filter(r => r.smarter.includes(attr) && r.juge.includes(attr)).length;
                        const countSmarterIncorrect = group.filter(r => r.smarter.includes(attr) && !r.juge.includes(attr)).length;
                        const countMissing = group.filter(r => !r.smarter.includes(attr) && r.juge.includes(attr)).length;

                        if (smarterHasAttr && jugeHasAttr) {
                            cellValue = countSmarterCorrect >= totalRows / 2 ? 'c_maj' : 'c_min';
                        } else if (smarterHasAttr && !jugeHasAttr) {
                            cellValue = countSmarterIncorrect >= totalRows / 2 ? 'i_maj' : 'i_min';
                        } else if (!smarterHasAttr && jugeHasAttr) {
                            cellValue = countMissing >= totalRows / 2 ? 'missing_maj' : 'missing_min';
                        }

                        const cell = rowElement.cells[Array.from(headerRow.cells).findIndex(c => c.textContent === attr)];
                        if (cell) {
                            cell.textContent = cellValue;
                        }
                    });

                    const asinJudgmentIndex = Array.from(headerRow.cells).findIndex(c => c.textContent === 'Jugement ASIN');
                    const asinJudgmentCell = rowElement.cells[asinJudgmentIndex];
                    const cellValues = Array.from(rowElement.cells).slice(headers.length, headers.length + uniqueKeys.size).map(cell => cell.textContent);

                    if (cellValues.includes('i_min') || cellValues.includes('i_maj') || cellValues.includes('missing_min') || cellValues.includes('missing_maj')) {
                        asinJudgmentCell.textContent = 'ko';
                    } else if ((cellValues.includes('c_min') || cellValues.includes('c_maj')) &&
                        !cellValues.includes('i_min') && !cellValues.includes('i_maj') &&
                        !cellValues.includes('missing_min') && !cellValues.includes('missing_maj')) {
                        asinJudgmentCell.textContent = 'ok';
                    }
                });
            });
        }
    });
}



		
		


	//CALCUL CONSENSUS PAR WORKER ID DETAILLES	
	function calculateConsensusWorker() {
    const resultTable = document.getElementById('resultTable');
    if (!resultTable) {
        console.error('Table with id "resultTable" not found.');
        return;
    }

    const headers = Array.from(resultTable.querySelectorAll('th')).map(th => th.innerText.trim());

    if (headers.indexOf('workerid') === -1) {
        console.error('Column "workerid" not found.');
        return;
    }

    const data = Array.from(resultTable.querySelectorAll('tbody tr')).map((row, rowIndex) => {
        const cells = Array.from(row.querySelectorAll('td'));
        const workeridCell = cells[headers.indexOf('workerid')];

        if (!workeridCell) {
            console.error(`WorkerID cell is missing in row ${rowIndex + 1}`);
            return null;
        }

        const rowData = {};
        headers.slice(headers.indexOf('juge') + 1).forEach(attr => {
            const cell = cells[headers.indexOf(attr)];
            if (!cell) {
                console.error(`Cell for attribute '${attr}' is missing in row ${rowIndex + 1}`);
            }
            rowData[attr] = cell?.innerText.trim() || '';
        });

        return {
            workerid: workeridCell.innerText.trim(),
            ...rowData
        };
    }).filter(row => row); // Filter out any rows that were null

    const summary = {};
    data.forEach(row => {
        if (!row) return;

        if (!summary[row.workerid]) {
            summary[row.workerid] = { 
                correct_majority: 0, 
                correct_minority: 0, 
                incorrect_majority: 0, 
                incorrect_minority: 0, 
                total: 0 
            };
        }

        Object.values(row).forEach(value => {
            if (value.includes('c_maj')) {
                summary[row.workerid].correct_majority += 1;
            }
            if (value.includes('c_min')) {
                summary[row.workerid].correct_minority += 1;
            }
            if (value.includes('i_maj') || value.includes('missing_maj')) {
                summary[row.workerid].incorrect_majority += 1;
            }
            if (value.includes('i_min') || value.includes('missing_min')) {
                summary[row.workerid].incorrect_minority += 1;
            }
        });

        summary[row.workerid].total = summary[row.workerid].correct_majority + 
                                      summary[row.workerid].correct_minority + 
                                      summary[row.workerid].incorrect_majority + 
                                      summary[row.workerid].incorrect_minority;
    });

    const totalCorrectMajority = Object.values(summary).reduce((sum, row) => sum + row.correct_majority, 0);
    const totalCorrectMinority = Object.values(summary).reduce((sum, row) => sum + row.correct_minority, 0);
    const totalIncorrectMajority = Object.values(summary).reduce((sum, row) => sum + row.incorrect_majority, 0);
    const totalIncorrectMinority = Object.values(summary).reduce((sum, row) => sum + row.incorrect_minority, 0);
    const grandTotal = totalCorrectMajority + totalCorrectMinority + totalIncorrectMajority + totalIncorrectMinority;

    const table = document.getElementById('consensusWorkerID');
    table.innerHTML = '';

    // Adding caption to the table
    const caption = table.createCaption();
    caption.textContent = 'WORKER ID CONSENSUS';

    const thead = document.createElement('thead');
    const tbody = document.createElement('tbody');

    const headerRow = document.createElement('tr');
    ['workerid', 'Correct Majority', 'taux %', 'Correct Minority', 'taux %', 'Incorrect Majority', 'taux %', 'Incorrect Minority', 'taux %', 'Total', 'Consensus Correctness (%)', 'Attribute Error Rate (%)'].forEach(text => {
        const th = document.createElement('th');
        th.innerText = text;
        headerRow.appendChild(th);
    });
    thead.appendChild(headerRow);

    Object.entries(summary).forEach(([workerid, { correct_majority, correct_minority, incorrect_majority, incorrect_minority, total }]) => {
        const correctMajorityPercentage = grandTotal > 0 ? (correct_majority * 100 / grandTotal).toFixed(2).replace('.', ',') + '%' : '0,00%';
        const correctMinorityPercentage = grandTotal > 0 ? (correct_minority * 100 / grandTotal).toFixed(2).replace('.', ',') + '%' : '0,00%';
        const incorrectMajorityPercentage = grandTotal > 0 ? (incorrect_majority * 100 / grandTotal).toFixed(2).replace('.', ',') + '%' : '0,00%';
        const incorrectMinorityPercentage = grandTotal > 0 ? (incorrect_minority * 100 / grandTotal).toFixed(2).replace('.', ',') + '%' : '0,00%';

        const consensusCorrectness = total > 0 ? formatPercentage((correct_majority + correct_minority) * 100 / (totalCorrectMajority + totalCorrectMinority)) : '0,00%';
        const errorRate = total > 0 ? formatPercentage((incorrect_majority + incorrect_minority) * 100 / (totalIncorrectMajority + totalIncorrectMinority)) : '0,00%';

        const row = document.createElement('tr');
        [workerid, correct_majority, correctMajorityPercentage, correct_minority, correctMinorityPercentage, incorrect_majority, incorrectMajorityPercentage, incorrect_minority, incorrectMinorityPercentage, formatTotal(total), consensusCorrectness, errorRate].forEach(text => {
            const td = document.createElement('td');
            td.innerText = text;
            row.appendChild(td);
        });

        tbody.appendChild(row);
    });

    const footerRow = document.createElement('tr');
    ['Total', formatTotal(totalCorrectMajority), formatPercentage(totalCorrectMajority * 100 / grandTotal), formatTotal(totalCorrectMinority), formatPercentage(totalCorrectMinority * 100 / grandTotal), formatTotal(totalIncorrectMajority), formatPercentage(totalIncorrectMajority * 100 / grandTotal), formatTotal(totalIncorrectMinority), formatPercentage(totalIncorrectMinority * 100 / grandTotal), formatTotal(grandTotal), formatPercentage((totalCorrectMajority + totalCorrectMinority) * 100 / grandTotal), formatPercentage((totalIncorrectMajority + totalIncorrectMinority) * 100 / grandTotal)].forEach(text => {
        const td = document.createElement('td');
        td.innerText = text;
        footerRow.appendChild(td);
    });

    tbody.appendChild(footerRow);
    table.appendChild(thead);
    table.appendChild(tbody);
     //SCROOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOLLLLLLLLLLLLLLLLLLL
	//var table = document.getElementById("consensusWorkerID");
	table.scrollIntoView({
                behavior: "smooth",  // Fait défiler de manière fluide
                block: "center"      // Centre la table dans la vue verticale de la page
            });
}



	//CALCUL ACCURACY WORKER ID
	function calculateAccuracyWorkerID() {
    const resultTable = document.getElementById('resultTable');
    if (!resultTable) {
        console.error('Table with id "resultTable" not found.');
        return;
    }

    const table = document.getElementById('accuracyWorkerID');
    if (!table) {
        console.error('Table with id "accuracyWorkerID" not found.');
        return;
    }

    // Réinitialiser le contenu de la table
    table.innerHTML = '';

    // Ajouter le caption à la table
    const caption = table.createCaption();
    caption.textContent = 'WORKER ID ACCURACY (%)';

    const headers = Array.from(resultTable.querySelectorAll('th')).map(th => th.innerText.trim());
    const data = Array.from(resultTable.querySelectorAll('tbody tr')).map(row => {
        const cells = Array.from(row.querySelectorAll('td'));
        const workeridCell = cells[headers.indexOf('workerid')];
        const jugementASINCell = cells[headers.indexOf('Jugement ASIN')];

        if (!workeridCell || !jugementASINCell) {
            console.error('One or more cells are missing in row:', row);
            return null;
        }

        return {
            workerid: workeridCell.innerText.trim(),
            jugementASIN: jugementASINCell.innerText.trim()
        };
    }).filter(row => row); // Filter out any rows that were null

    const workerSummary = {};
    let totalCorrect = 0;
    let totalIncorrect = 0;

    data.forEach(row => {
        if (!row) return;

        if (!workerSummary[row.workerid]) {
            workerSummary[row.workerid] = { Correct: 0, Incorrect: 0 };
        }

        if (row.jugementASIN === 'ok') {
            workerSummary[row.workerid].Correct += 1;
            totalCorrect += 1;
        } else if (row.jugementASIN === 'ko') {
            workerSummary[row.workerid].Incorrect += 1;
            totalIncorrect += 1;
        }
    });

    const thead = document.createElement('thead');
    const tbody = document.createElement('tbody');

    const headerRow = document.createElement('tr');
    ['workerid', 'Correct', 'Incorrecte', 'Total ASIN traité', 'Accuracy (%)', 'Error Rate (%)'].forEach(text => {
        const th = document.createElement('th');
        th.innerText = text;
        headerRow.appendChild(th);
    });
    thead.appendChild(headerRow);

    Object.keys(workerSummary).forEach(workerid => {
        const summary = workerSummary[workerid];
        const totalASIN = summary.Correct + summary.Incorrect;
        const accuracy = totalASIN > 0 ? formatPercentage((summary.Correct / totalASIN * 100)) : '0,00%';
        const errorRate = totalASIN > 0 ? formatPercentage((summary.Incorrect / totalASIN * 100)) : '0,00%';

        const row = document.createElement('tr');
        [workerid, summary.Correct, summary.Incorrect, formatTotal(totalASIN), accuracy, errorRate].forEach(text => {
            const td = document.createElement('td');
            td.innerText = text;
            row.appendChild(td);
        });

        tbody.appendChild(row);
    });

    const footerRow = document.createElement('tr');
    const totalRow = {
        Correct: totalCorrect,
        Incorrect: totalIncorrect,
        TotalASIN: totalCorrect + totalIncorrect
    };
    const accuracy = totalRow.TotalASIN > 0 ? formatPercentage((totalRow.Correct / totalRow.TotalASIN * 100)) : '0,00%';
    const errorRate = totalRow.TotalASIN > 0 ? formatPercentage((totalRow.Incorrect / totalRow.TotalASIN * 100)) : '0,00%';

    ['Total général', formatTotal(totalRow.Correct), formatTotal(totalRow.Incorrect), formatTotal(totalRow.TotalASIN), accuracy, errorRate].forEach(text => {
        const td = document.createElement('td');
        td.innerText = text;
        footerRow.appendChild(td);
    });

    tbody.appendChild(footerRow);
    table.appendChild(thead);
    table.appendChild(tbody);
    //SCROOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOLLLLLLLLLLLLLLLLLLL
	//var table = document.getElementById("accuracyWorkerID");
	table.scrollIntoView({
                behavior: "smooth",  // Fait défiler de manière fluide
                block: "center"      // Centre la table dans la vue verticale de la page
            });
}

// Ensure the caption is visible with CSS
const style = document.createElement('style');
style.innerHTML = `
    table caption {
        caption-side: top;
        font-weight: bold;
        font-size: 1.2em;
        text-align: center;
        margin-bottom: 10px;
    }
`;
document.head.appendChild(style);



		
		
		// CALCUL AGREEMENT
		function agreement() {
    const resultTable = document.getElementById('resultTable');
    if (!resultTable) {
        console.error('Table with id "resultTable" not found.');
        return;
    }

    const table = document.getElementById('agreementTable');
    if (!table) {
        console.error('Table with id "agreementTable" not found.');
        return;
    }

    // Adding caption to the table
    const caption = table.createCaption();
    caption.textContent = 'SUMMARY AGREEMENT';

    const headers = Array.from(resultTable.querySelectorAll('th')).map(th => th.innerText.trim());
    const data = Array.from(resultTable.querySelectorAll('tbody tr')).map(row => {
        const cells = Array.from(row.querySelectorAll('td'));
        const rowData = {};
        headers.forEach((header, index) => {
            rowData[header] = cells[index] ? cells[index].innerText.trim() : '';
        });
        return rowData;
    });

    const summary = {
        CorrectMajority: 0,
        CorrectMinority: 0,
        IncorrectMajority: 0,
        IncorrectMinority: 0
    };

    const attributeHeaders = headers.slice(headers.indexOf('juge') + 1).filter(header => header !== 'Jugement ASIN' && header !== 'Jugement Assignement');
    const totalASINs = data.length;

    data.forEach(row => {
        attributeHeaders.forEach(attr => {
            if (row[attr] === 'c_maj') {
                summary.CorrectMajority += 1;
            } else if (row[attr] === 'c_min') {
                summary.CorrectMinority += 1;
            } else if (row[attr] === 'i_maj' || row[attr] === 'missing_maj') {
                summary.IncorrectMajority += 1;
            } else if (row[attr] === 'i_min' || row[attr] === 'missing_min') {
                summary.IncorrectMinority += 1;
            }
        });
    });

    const totalAgreements = summary.CorrectMajority + summary.CorrectMinority + summary.IncorrectMajority + summary.IncorrectMinority;

    table.innerHTML = '';

    const tbody = document.createElement('tbody');
    const headerRow = document.createElement('tr');
    const th = document.createElement('th');
    th.colSpan = 3;
    th.innerText = `Total agreement in ${totalASINs - 1} processed ASINs`;
    headerRow.appendChild(th);
    tbody.appendChild(headerRow);

    const formattedData = [
        ['Correct Majority', formatTotal(summary.CorrectMajority), formatPercentage(summary.CorrectMajority / totalAgreements * 100)],
        ['Correct Minority', formatTotal(summary.CorrectMinority), formatPercentage(summary.CorrectMinority / totalAgreements * 100)],
        ['Incorrect Majority', formatTotal(summary.IncorrectMajority), formatPercentage(summary.IncorrectMajority / totalAgreements * 100)],
        ['Incorrect Minority', formatTotal(summary.IncorrectMinority), formatPercentage(summary.IncorrectMinority / totalAgreements * 100)],
        ['Total:', formatTotal(totalAgreements), '']
    ];

    formattedData.forEach(rowData => {
        const row = document.createElement('tr');
        rowData.forEach(text => {
            const td = document.createElement('td');
            td.innerText = text;
            row.appendChild(td);
        });
        tbody.appendChild(row);
    });

    table.appendChild(tbody);
    //SCROOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOLLLLLLLLLLLLLLLLLLL
	//var table = document.getElementById("agreementTable");
	table.scrollIntoView({
                behavior: "smooth",  // Fait défiler de manière fluide
                block: "center"      // Centre la table dans la vue verticale de la page
            });
}
		
		
		//CALCUL SUMMARY ENTIRELY BATCH
		function Summary() {
    const resultTable = document.getElementById('resultTable');
    if (!resultTable) {
        console.error('Table with id "resultTable" not found.');
        return;
    }

    const caption = resultTable.createCaption();
    caption.textContent = 'SUMMARY INDEX';

    const headers = Array.from(resultTable.querySelectorAll('th')).map(th => th.innerText.trim());
    const data = Array.from(resultTable.querySelectorAll('tbody tr')).map(row => {
        const cells = Array.from(row.querySelectorAll('td'));
        const rowData = {};
        headers.forEach((header, index) => {
            rowData[header] = cells[index] ? cells[index].innerText.trim() : '';
        });
        return rowData;
    });

    const uniqueHITIDs = new Set();
    const uniqueWorkerIDs = new Set();
    let totalASINs = 0;
    let correctASINs = 0;
    let incorrectASINs = 0;

    data.forEach(row => {
        uniqueHITIDs.add(row['hitid']);
        uniqueWorkerIDs.add(row['workerid']);
        totalASINs += 1;
        if (row['Jugement ASIN'] === 'ok') {
            correctASINs += 1;
        } else if (row['Jugement ASIN'] === 'ko') {
            incorrectASINs += 1;
        }
    });

    const globalAccuracy = (correctASINs / totalASINs * 100).toFixed(2);

    const table = document.getElementById('summaryTable');
    table.innerHTML = '';

    const tbody = document.createElement('tbody');
    const headerRow = document.createElement('tr');
    const th = document.createElement('th');
    th.colSpan = 2;
    th.innerText = 'Summary';
    headerRow.appendChild(th);
    tbody.appendChild(headerRow);

    const formattedData = [
        ['Unique HITIDs', formatTotal(uniqueHITIDs.size - 1)],
        ['WorkerIDs', formatTotal(uniqueWorkerIDs.size - 1)],
        ['Total ASIN Analyzed', formatTotal(totalASINs - 1)],
        ['Correct ASINs', formatTotal(correctASINs)],
        ['Incorrect ASINs', formatTotal(incorrectASINs)],
        ['Global Accuracy', formatPercentage(globalAccuracy)]
    ];

    formattedData.forEach(rowData => {
        const row = document.createElement('tr');
        rowData.forEach(text => {
            const td = document.createElement('td');
            td.innerText = text;
            row.appendChild(td);
        });
        tbody.appendChild(row);
    });

    table.appendChild(tbody);
    //SCROOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOLLLLLLLLLLLLLLLLLLL
	//var table = document.getElementById("summaryTable");
	table.scrollIntoView({
                behavior: "smooth",  // Fait défiler de manière fluide
                block: "center"      // Centre la table dans la vue verticale de la page
            });
}



	function DetailedAttributConsensus() {
    const resultTable = document.getElementById('resultTable');
    const attributes = {};

    // Trouver les en-têtes de colonnes
    const headers = Array.from(resultTable.querySelectorAll('th')).map(th => th.innerText.trim());

    // Trouver l'index de la colonne 'juge' et des colonnes d'attributs
    const jugeIndex = headers.indexOf('juge');
    const attributeColumns = headers.slice(jugeIndex + 1).filter(col => col !== 'Jugement ASIN' && col !== 'Jugement Assignement' && col !== 'Jugement HitId');

    if (jugeIndex === -1) {
        console.error('Colonne "juge" non trouvée');
        return;
    }

    // Initialiser les attributs pour les colonnes
    attributeColumns.forEach(attr => {
        attributes[attr] = {
            correctMajority: 0,
            correctMinority: 0,
            incorrectMajority: 0,
            incorrectMinority: 0
        };
    });

    // Collecter les données de la table existante
    for (let i = 1; i < resultTable.rows.length; i++) {
        const row = resultTable.rows[i];
        const cellValues = row.cells;

        attributeColumns.forEach((attr, index) => {
            const cellIndex = jugeIndex + 1 + index;
            if (cellIndex < cellValues.length) {
                const value = cellValues[cellIndex].textContent.trim();

                if (value === 'c_maj') {
                    attributes[attr].correctMajority++;
                } else if (value === 'c_min') {
                    attributes[attr].correctMinority++;
                } else if (value === 'i_maj' || value === 'missing_maj') {
                    attributes[attr].incorrectMajority++;
                } else if (value === 'i_min' || value === 'missing_min') {
                    attributes[attr].incorrectMinority++;
                }
            }
        });
    }

    // Calculer les totaux globaux
    let grandTotalCorrectMajority = 0;
    let grandTotalCorrectMinority = 0;
    let grandTotalIncorrectMajority = 0;
    let grandTotalIncorrectMinority = 0;

    Object.values(attributes).forEach(data => {
        grandTotalCorrectMajority += data.correctMajority;
        grandTotalCorrectMinority += data.correctMinority;
        grandTotalIncorrectMajority += data.incorrectMajority;
        grandTotalIncorrectMinority += data.incorrectMinority;
    });

    // Calculer le grand total général
    const grandTotal = grandTotalCorrectMajority + grandTotalCorrectMinority + grandTotalIncorrectMajority + grandTotalIncorrectMinority;

    // Référencer la table existante
    const detailedTable = document.getElementById('consensusAttributDetailed');

    // Réinitialiser le contenu de la table
    detailedTable.innerHTML = '';

    // Ajouter une légende à la table
    const caption = detailedTable.createCaption();
    caption.textContent = 'ATTRIBUTS CONSENSUS';

    // Ajouter l'en-tête
    const headerRowNew = detailedTable.insertRow();
    const newHeaders = [
        'Attributs',
        'Correct Majority',
        'Taux %',
        'Correct Minority',
        'Taux %',
        'Incorrect Majority',
        'Taux %',
        'Incorrect Minority',
        'Taux %',
        'Total',
        'Consensus Correctness (%)',
        'Attribute Error Rate (%)'
    ];

    newHeaders.forEach(header => {
        const cell = document.createElement('th');
        cell.textContent = header;
        headerRowNew.appendChild(cell);
    });

    // Ajouter les lignes de données
    Object.keys(attributes).forEach(attr => {
        const data = attributes[attr];
        const total = data.correctMajority + data.correctMinority + data.incorrectMajority + data.incorrectMinority;

        const row = detailedTable.insertRow();
        row.insertCell().textContent = attr;
        row.insertCell().textContent = data.correctMajority;
        row.insertCell().textContent = grandTotal > 0 ? (data.correctMajority * 100 / grandTotal).toFixed(2).replace('.', ',') + '%' : '0,00%';
        row.insertCell().textContent = data.correctMinority;
        row.insertCell().textContent = grandTotal > 0 ? (data.correctMinority * 100 / grandTotal).toFixed(2).replace('.', ',') + '%' : '0,00%';
        row.insertCell().textContent = data.incorrectMajority;
        row.insertCell().textContent = grandTotal > 0 ? (data.incorrectMajority * 100 / grandTotal).toFixed(2).replace('.', ',') + '%' : '0,00%';
        row.insertCell().textContent = data.incorrectMinority;
        row.insertCell().textContent = grandTotal > 0 ? (data.incorrectMinority * 100 / grandTotal).toFixed(2).replace('.', ',') + '%' : '0,00%';

        row.insertCell().textContent = total;

        const consensusCorrectness = (grandTotalCorrectMajority + grandTotalCorrectMinority > 0)
            ? ((data.correctMajority + data.correctMinority) / grandTotal * 100).toFixed(2).replace('.', ',') + '%'
            : '0,00%';
        row.insertCell().textContent = consensusCorrectness;

        const attributeErrorRate = (grandTotalIncorrectMajority + grandTotalIncorrectMinority > 0)
            ? ((data.incorrectMajority + data.incorrectMinority) / grandTotal * 100).toFixed(2).replace('.', ',') + '%'
            : '0,00%';
        row.insertCell().textContent = attributeErrorRate;
    });

    // Ajouter la ligne totale
    const totalRow = detailedTable.insertRow();
    totalRow.insertCell().textContent = 'Total';
    totalRow.insertCell().textContent = grandTotalCorrectMajority;
    totalRow.insertCell().textContent = grandTotal > 0 ? (grandTotalCorrectMajority * 100 / grandTotal).toFixed(2).replace('.', ',') + '%' : '0,00%';
    totalRow.insertCell().textContent = grandTotalCorrectMinority;
    totalRow.insertCell().textContent = grandTotal > 0 ? (grandTotalCorrectMinority * 100 / grandTotal).toFixed(2).replace('.', ',') + '%' : '0,00%';
    totalRow.insertCell().textContent = grandTotalIncorrectMajority;
    totalRow.insertCell().textContent = grandTotal > 0 ? (grandTotalIncorrectMajority * 100 / grandTotal).toFixed(2).replace('.', ',') + '%' : '0,00%';
    totalRow.insertCell().textContent = grandTotalIncorrectMinority;
    totalRow.insertCell().textContent = grandTotal > 0 ? (grandTotalIncorrectMinority * 100 / grandTotal).toFixed(2).replace('.', ',') + '%' : '0,00%';

    totalRow.insertCell().textContent = grandTotal;

    const totalConsensusCorrectness = (grandTotalCorrectMajority + grandTotalCorrectMinority > 0)
        ? ((grandTotalCorrectMajority + grandTotalCorrectMinority) / grandTotal * 100).toFixed(2).replace('.', ',') + '%'
        : '0,00%';
    totalRow.insertCell().textContent = totalConsensusCorrectness;

    const totalAttributeErrorRate = (grandTotalIncorrectMajority + grandTotalIncorrectMinority > 0)
        ? ((grandTotalIncorrectMajority + grandTotalIncorrectMinority) / grandTotal * 100).toFixed(2).replace('.', ',') + '%'
        : '0,00%';
    totalRow.insertCell().textContent = totalAttributeErrorRate;
     //SCROOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOLLLLLLLLLLLLLLLLLLL
	//var table = document.getElementById("consensusAttributDetailed");
	table.scrollIntoView({
                behavior: "smooth",  // Fait défiler de manière fluide
                block: "center"      // Centre la table dans la vue verticale de la page
            });
}






// FONCTION POUR COPIER LES RESULTATS A CHANGER PROCHAINEMENT
// Fonction pour copier le contenu d'une table dans le presse-papiers
async function copyTableToClipboard(table) {
    if (!table) {
        console.error('Table non trouvée.');
        return;
    }

    // Vérifier si la table est vide
    if (!table.innerText.trim()) {
        alert('Table vide');
        return;
    }

    try {
        // Obtenir le contenu de la table
        const tableText = table.innerText;

        // Copier le contenu dans le presse-papiers en utilisant l'API Clipboard
        await navigator.clipboard.writeText(tableText);

        // Obtenir l'ID de la table
        const tableId = table.id || 'sans ID';

        // Afficher une notification pour l'utilisateur avec l'ID de la table
        alert(`Table ${tableId} copiée dans le presse-papiers!`);
    } catch (err) {
        console.error('Erreur lors de la copie dans le presse-papiers:', err);
    }
}

// Ajouter l'événement click pour copier une table
document.querySelectorAll('table').forEach(table => {
    table.onclick = () => {
        copyTableToClipboard(table);
    };
});


//////////////////////////////////////////////////////////////////////////////////////////////
document.getElementById('extract_data').onclick = function() {
    // Indexer les colonnes importantes
    const resultTable = document.getElementById('resultTable');
    const rows = resultTable.getElementsByTagName('tr');
    const header = rows[0].getElementsByTagName('th');
    let indexes = {};

    for (let i = 0; i < header.length; i++) {
        const colName = header[i].innerText.trim();
        if (['hitid', 'AssignmentId', 'Jugement ASIN', 'Jugement Assignement', 'Jugement HitId'].includes(colName)) {
            indexes[colName] = i;
        }
    }

    // Initialiser les sets et compteurs
    let assignmentSet = new Set();
    let assignmentKOSet = new Set();
    let hitSet = new Set();
    let hitKOSet = new Set();
    let attributeCounts = {
        correct_majority: 0,
        correct_minority: 0,
        incorrect_majority: 0,
        incorrect_minority: 0
    };

    // AJOUTER ICI TOUT LES ATTRIBUTS NECESSAIRES POUR LE CALCUL DE CRJ DETAILS
    let attributeColumns = ['asin_image_not_load', 'wrong_age_group', 'wrong_category', 'color', 'pattern', 'material', 'size', 'shape', 'support_type', 'extra_features', 'location', 'no_difference','has_product_difference', 'is_wrong_characteristic', 'is_wrong_size_or_count', 'is_wrong_bundle', 'is_wrong_packaging_overlay', 'is_non_targeted_match'];

    // Parcourir les lignes du tableau
    for (let i = 1; i < rows.length; i++) {
        const cells = rows[i].getElementsByTagName('td');
        const assignmentId = cells[indexes['AssignmentId']].innerText.trim();
        const hitId = cells[indexes['hitid']].innerText.trim();
        const jugementAssignment = cells[indexes['Jugement Assignement']].innerText.trim();
        const jugementHitId = cells[indexes['Jugement HitId']].innerText.trim();

        // Remplir les sets et compteurs pour CRJ_Table1
        assignmentSet.add(assignmentId);
        if (jugementAssignment === 'assignement_ko') {
            assignmentKOSet.add(assignmentId);
        }

        // Remplir les sets et compteurs pour CRJ_Table2
        hitSet.add(hitId);
        if (jugementHitId === 'hitid_ko') {
            hitKOSet.add(hitId);
        }

        // Compter les attributs
        attributeColumns.forEach(attr => {
            const attrIndex = Array.from(header).findIndex(th => th.innerText.trim() === attr);
            if (attrIndex !== -1) {
                const attrValue = cells[attrIndex].innerText.trim();
                if (attrValue === 'c_maj') {
                    attributeCounts.correct_majority++;
                } else if (attrValue === 'c_min') {
                    attributeCounts.correct_minority++;
                } else if (attrValue === 'i_maj' || attrValue === 'missing_maj') {
                    attributeCounts.incorrect_majority++;
                } else if (attrValue === 'i_min' || attrValue === 'missing_min') {
                    attributeCounts.incorrect_minority++;
                }
            }
        });
    }

    // Calculer le taux d'erreurs
    const assignmentEchantillonne = assignmentSet.size;
    const assignmentKO = assignmentKOSet.size;
    const tauxErreurs = (assignmentKO / assignmentEchantillonne) * 100;
    const formattedTauxErreurs = formatPercentage(tauxErreurs);

    // Récupérer la valeur sélectionnée dans la liste déroulante
    const selectedIndexType = document.getElementById('indextype').value;

    // Vider CRJ_Table1 avant de remplir
    const CRJ_Table1 = document.getElementById('CRJ_Table1');
    CRJ_Table1.innerHTML = ''; // Vider le contenu de la table
    const headerRow1 = CRJ_Table1.insertRow();
    ['Assignment échantillonné', 'Taux d\'erreurs', 'Assignment KO', 'Détail'].forEach(text => {
        const th = document.createElement('th');
        th.innerText = text;
        headerRow1.appendChild(th);
    });
    const row1 = CRJ_Table1.insertRow();
    row1.insertCell(0).innerText = assignmentEchantillonne;
    row1.insertCell(1).innerText = formattedTauxErreurs;
    row1.insertCell(2).innerText = assignmentKO;
    row1.insertCell(3).innerText = selectedIndexType;  // Insérer la valeur sélectionnée ici

    // Calculer le total des attributs
    const totalAttributes = attributeCounts.correct_majority + attributeCounts.correct_minority + attributeCounts.incorrect_majority + attributeCounts.incorrect_minority;

    // Calculer les pourcentages
    const correctMajorityPercentage = formatPercentage((attributeCounts.correct_majority / totalAttributes) * 100);
    const correctMinorityPercentage = formatPercentage((attributeCounts.correct_minority / totalAttributes) * 100);
    const incorrectMajorityPercentage = formatPercentage((attributeCounts.incorrect_majority / totalAttributes) * 100);
    const incorrectMinorityPercentage = formatPercentage((attributeCounts.incorrect_minority / totalAttributes) * 100);

    // Vider CRJ_Table2 avant de remplir
    const CRJ_Table2 = document.getElementById('CRJ_Table2');
    CRJ_Table2.innerHTML = ''; // Vider le contenu de la table
    const headerRow2 = CRJ_Table2.insertRow();
    ['HIT contrôlé', 'HIT KO', 'CORRECT_MAJORITY', 'CORRECT_MINORITY', 'INCORRECT_MAJORITY', 'INCORRECT_MINORITY'].forEach(text => {
        const th = document.createElement('th');
        th.innerText = text;
        headerRow2.appendChild(th);
    });
    const row2 = CRJ_Table2.insertRow();
	const row3 = CRJ_Table2.insertRow();
    row2.insertCell(0).innerText = hitSet.size;
    row2.insertCell(1).innerText = hitKOSet.size;
    row2.insertCell(2).innerText = correctMajorityPercentage;
    row2.insertCell(3).innerText = correctMinorityPercentage;
    row2.insertCell(4).innerText = incorrectMajorityPercentage;
    row2.insertCell(5).innerText = incorrectMinorityPercentage;
	
	//AFFICHER TOTAL EN BAS DE LA TABLE (LES NOMBRES DE C_MAJ, C_MIN, I_MAJ ET I_MIN
	row3.insertCell(0).innerText = hitSet.size;
    row3.insertCell(1).innerText = hitKOSet.size;
    row3.insertCell(2).innerText = attributeCounts.correct_majority;
    row3.insertCell(3).innerText = attributeCounts.correct_minority;
    row3.insertCell(4).innerText = attributeCounts.incorrect_majority;
    row3.insertCell(5).innerText = attributeCounts.incorrect_minority;
};

/////////////////////////////////////////////////////////////////////////////////////////////
//FONCTION POUR SUMMARY ET AGREEMENT
function executeBoth() {
    agreement();
    Summary();
}

function formatPercentage(value) {
    return `${parseFloat(value).toFixed(2).replace('.', ',')}%`;
}

function formatTotal(value) {
    return parseInt(value).toLocaleString('fr-FR');
}


//SCRIPT POUR LE TOP WORKER ET LOW PERFORMANCE PAGE
		//SCRIPT POUR AVOIR LE DONNEES GLOBALE POUR LE CALCUL
        document.getElementById('csvFileInput').addEventListener('change', handleFileSelect, false);
        function handleFileSelect(event) {
            const file = event.target.files[0];
            Papa.parse(file, {
                header: true,
                delimiter: '\t', // Délimiteur de tabulation
                skipEmptyLines: true,
                preview: 500000, // Augmentez le nombre de lignes prévisualisées si nécessaire
                dynamicTyping: true,
                complete: function(results) {
                    const data = results.data;
                    const headers = results.meta.fields;
                    const requiredHeaders = ["hitid", "AssignmentId", "workerid", "Input.imageURL", "Input.bbox", "Input.content", "Answer.output_data", "amazon.image", "Market place", "Input.matches", "key", "assin_json", "assin_juge_json"];

                    // Vérifier si toutes les en-têtes requises sont présentes
                    if (!requiredHeaders.every(header => headers.includes(header))) {
                        alert('CSV file is missing required headers.');
                        return;
                    }

                    // Créer une liste d'attributs uniques
                    let uniqueAttributes = new Set();
                    data.forEach(row => {
                        const assinJsonAttrs = row.assin_json ? row.assin_json.split(',').map(attr => attr.trim()) : [];
                        const assinJugeJsonAttrs = row.assin_juge_json ? row.assin_juge_json.split(',').map(attr => attr.trim()) : [];
                        assinJsonAttrs.forEach(attr => uniqueAttributes.add(attr));
                        assinJugeJsonAttrs.forEach(attr => uniqueAttributes.add(attr));
                    });

                    uniqueAttributes = Array.from(uniqueAttributes).filter(attr => attr !== '');

                    // Reproduire le tableau original et ajouter les colonnes d'attributs
                    const table = document.getElementById('resultstable');
                    table.innerHTML = ''; // Vider le tableau précédent
					// Add a title to the table
					const caption = table.createCaption();
					caption.textContent = 'EVALUATION OF SMARTER RESPONSES FOR EACH PROCESSED ASIN'; // Titre du tableau
                    // Créer l'en-tête du tableau
                    const headerRow = table.insertRow();
                    headers.forEach(header => {
                        const cell = headerRow.insertCell();
                        cell.textContent = header;
                    });
                    uniqueAttributes.forEach(attr => {
                        const cell = headerRow.insertCell();
                        cell.textContent = attr; // Met le texte en italique
                    });

                    // Créer les lignes du tableau avec indices
                    const rowsWithIndex = data.map((row, index) => ({ ...row, index: index + 1 }));
                    rowsWithIndex.forEach(row => {
                        const rowElement = table.insertRow();
                        headers.forEach(header => {
                            const cell = rowElement.insertCell();
                            cell.textContent = row[header] !== undefined ? row[header] : '';
                        });
                        uniqueAttributes.forEach(attr => {
                            const cell = rowElement.insertCell();
                            cell.textContent = ''; // Placeholder for analysis results
                        });
                    });

                    // Analyser les données
                    analyzeData(rowsWithIndex, uniqueAttributes, table);
                }
            });
        }

        function analyzeData(data, uniqueAttributes, table) {
            const keyGroups = data.reduce((acc, row) => {
                if (!acc[row.key]) acc[row.key] = [];
                acc[row.key].push(row);
                return acc;
            }, {});

            Object.keys(keyGroups).forEach(key => {
                const group = keyGroups[key];
                const totalRows = group.length;

                uniqueAttributes.forEach(attr => {
                    let correctCount = 0;
                    let incorrectCount = 0;
                    let missingCount = 0;

                    group.forEach(row => {
                        const assinJsonAttrs = row.assin_json ? row.assin_json.split(',').map(a => a.trim()) : [];
                        const assinJugeJsonAttrs = row.assin_juge_json ? row.assin_juge_json.split(',').map(a => a.trim()) : [];

                        if (assinJsonAttrs.includes(attr) && assinJugeJsonAttrs.includes(attr)) correctCount++;
                        else if (assinJsonAttrs.includes(attr) && !assinJugeJsonAttrs.includes(attr)) incorrectCount++;
                        else if (!assinJsonAttrs.includes(attr) && assinJugeJsonAttrs.includes(attr)) missingCount++;
                    });

                    // Déterminer si l'attribut est majoritaire ou minoritaire
                    const isMajority = count => count >= totalRows / 2;
                    const attributeIndex = table.rows[0].cells.length - uniqueAttributes.length + uniqueAttributes.indexOf(attr);

                    group.forEach((row, rowIndex) => {
                        const cell = table.rows[row.index].cells[attributeIndex]; // Utiliser row.index pour accéder à la bonne cellule

                        if (row.assin_json ? row.assin_json.split(',').map(a => a.trim()).includes(attr) : false) {
                            if (row.assin_juge_json ? row.assin_juge_json.split(',').map(a => a.trim()).includes(attr) : false) {
                                cell.textContent = correctCount > 0 && isMajority(correctCount) ? 'c_maj' : correctCount > 0 ? 'c_min' : '';
                            } else {
                                cell.textContent = incorrectCount > 0 && isMajority(incorrectCount) ? 'i_maj' : incorrectCount > 0 ? 'i_min' : '';
                            }
                        } else if (row.assin_juge_json ? row.assin_juge_json.split(',').map(a => a.trim()).includes(attr) : false) {
                            cell.textContent = missingCount > 0 && isMajority(missingCount) ? 'missing_maj' : missingCount > 0 ? 'missing_min' : '';
                        } else {
                            cell.textContent = '';
                        }
                    });
                });
            });
        }

			
		//RECENSER TOP CORRECT MAJORITY
		function recenseTopCMaj() {
    let resultTable = document.getElementById("resultstable");
    let headers = resultTable.rows[0].cells;

    let workerIdIndex = -1;
    let attributeIndexes = [];
    for (let i = 0; i < headers.length; i++) {
        let header = headers[i].textContent.trim();
        if (header === 'workerid') {
            workerIdIndex = i;
        } else if (header !== 'hitid' && header !== 'AssignmentId' && header !== 'Input.imageURL' && header !== 'Input.bbox' && header !== 'Input.content' && header !== 'Answer.output_data' && header !== 'amazon.image' && header !== 'Market place' && header !== 'Input.matches' && header !== 'key' && header !== 'assin_json' && header !== 'assin_juge_json') {
            attributeIndexes.push(i);
        }
    }

    if (workerIdIndex === -1 || attributeIndexes.length === 0) {
        console.error("Les colonnes 'workerid' ou attributs sont manquantes.");
        return;
    }

    let workerIdCount = {};
    for (let i = 1; i < resultTable.rows.length; i++) {
        let cells = resultTable.rows[i].cells;
        let workerId = cells[workerIdIndex].textContent.trim();
        if (!workerIdCount[workerId]) {
            workerIdCount[workerId] = {};
        }
        for (let index of attributeIndexes) {
            let attribute = headers[index].textContent.trim();
            let value = cells[index].textContent.trim();
            if (value === 'c_maj') {
                if (!workerIdCount[workerId][attribute]) {
                    workerIdCount[workerId][attribute] = 0;
                }
                workerIdCount[workerId][attribute]++;
            }
        }
    }

    let topResults = {};
    for (let index of attributeIndexes) {
        let attribute = headers[index].textContent.trim();
        let counts = [];
        for (let workerId in workerIdCount) {
            if (workerIdCount[workerId][attribute]) {
                counts.push([workerId, workerIdCount[workerId][attribute]]);
            }
        }
        counts.sort((a, b) => b[1] - a[1]);
        topResults[attribute] = counts.slice(0, 10);
    }

    let resultsTopCMaj = document.getElementById("resultsTopCMaj");
    resultsTopCMaj.innerHTML = ''; // Vider le tableau précédent s'il existe

    // Ajouter la légende
    let caption = resultsTopCMaj.createCaption();
    caption.textContent = "CORRECT MAJORITY";
	

    // Ajouter la ligne des en-têtes
    let headerRow = resultsTopCMaj.insertRow();
    headerRow.insertCell().textContent = 'Attribute';
    for (let index of attributeIndexes) {
        let headerCell = headerRow.insertCell();
        headerCell.textContent = headers[index].textContent.trim();
    }

    let totalRow = resultsTopCMaj.insertRow();
    let totalCell = totalRow.insertCell();
    totalCell.textContent = 'Total';
    for (let attribute of attributeIndexes) {
        let totalCell = totalRow.insertCell();
        let attributeTotal = topResults[headers[attribute].textContent.trim()].reduce((sum, item) => sum + item[1], 0);
        totalCell.innerHTML = `<strong>${attributeTotal}</strong>`; // Mettre le texte en gras avec HTML
    }

    for (let place = 0; place < 10; place++) {
        let row = resultsTopCMaj.insertRow();
        let placeCell = row.insertCell();
        placeCell.textContent = (place + 1) + ' Place';
        for (let attribute of attributeIndexes) {
            let cell = row.insertCell();
            let attributeName = headers[attribute].textContent.trim();
            if (topResults[attributeName][place]) {
                cell.innerHTML = `${topResults[attributeName][place][0]} (<strong>${topResults[attributeName][place][1]}</strong>)`;
            } else {
                cell.textContent = '';
            }
        }
    }
}
		//RECENSER TOP CORRECT MINORITY
		function recenseTopCMin() {
    let resultTable = document.getElementById("resultstable");
    let headers = resultTable.rows[0].cells;

    let workerIdIndex = -1;
    let attributeIndexes = [];
    for (let i = 0; i < headers.length; i++) {
        let header = headers[i].textContent.trim();
        if (header === 'workerid') {
            workerIdIndex = i;
        } else if (header !== 'hitid' && header !== 'AssignmentId' && header !== 'Input.imageURL' && header !== 'Input.bbox' && header !== 'Input.content' && header !== 'Answer.output_data' && header !== 'amazon.image' && header !== 'Market place' && header !== 'Input.matches' && header !== 'key' && header !== 'assin_json' && header !== 'assin_juge_json') {
            attributeIndexes.push(i);
        }
    }

    if (workerIdIndex === -1 || attributeIndexes.length === 0) {
        console.error("Les colonnes 'workerid' ou attributs sont manquantes.");
        return;
    }

    let workerIdCount = {};
    for (let i = 1; i < resultTable.rows.length; i++) {
        let cells = resultTable.rows[i].cells;
        let workerId = cells[workerIdIndex].textContent.trim();
        if (!workerIdCount[workerId]) {
            workerIdCount[workerId] = {};
        }
        for (let index of attributeIndexes) {
            let attribute = headers[index].textContent.trim();
            let value = cells[index].textContent.trim();
            if (value === 'c_min') {
                if (!workerIdCount[workerId][attribute]) {
                    workerIdCount[workerId][attribute] = 0;
                }
                workerIdCount[workerId][attribute]++;
            }
        }
    }

    let topResults = {};
    for (let index of attributeIndexes) {
        let attribute = headers[index].textContent.trim();
        let counts = [];
        for (let workerId in workerIdCount) {
            if (workerIdCount[workerId][attribute]) {
                counts.push([workerId, workerIdCount[workerId][attribute]]);
            }
        }
        counts.sort((a, b) => b[1] - a[1]);
        topResults[attribute] = counts.slice(0, 10);
    }

    let resultsTopCMin = document.getElementById("resultsTopCMin");
    resultsTopCMin.innerHTML = ''; // Vider le tableau précédent s'il existe

    // Ajouter la légende
    let caption = resultsTopCMin.createCaption();
    caption.textContent = "CORRECT MINORITY";
	

    // Ajouter la ligne des en-têtes
    let headerRow = resultsTopCMin.insertRow();
    headerRow.insertCell().textContent = 'Attribute';
    for (let index of attributeIndexes) {
        let headerCell = headerRow.insertCell();
        headerCell.textContent = headers[index].textContent.trim();
    }

    let totalRow = resultsTopCMin.insertRow();
    let totalCell = totalRow.insertCell();
    totalCell.textContent = 'Total';
    for (let attribute of attributeIndexes) {
        let totalCell = totalRow.insertCell();
        let attributeTotal = topResults[headers[attribute].textContent.trim()].reduce((sum, item) => sum + item[1], 0);
        totalCell.innerHTML = `<strong>${attributeTotal}</strong>`; // Mettre le texte en gras avec HTML
    }

    for (let place = 0; place < 10; place++) {
        let row = resultsTopCMin.insertRow();
        let placeCell = row.insertCell();
        placeCell.textContent = (place + 1) + ' Place';
        for (let attribute of attributeIndexes) {
            let cell = row.insertCell();
            let attributeName = headers[attribute].textContent.trim();
            if (topResults[attributeName][place]) {
                cell.innerHTML = `${topResults[attributeName][place][0]} (<strong>${topResults[attributeName][place][1]}</strong>)`;
            } else {
                cell.textContent = '';
            }
        }
    }
}
		//RECENSER TOP INCORRECT MAJORITY + MISSING MAJORITY
		function recenseTopIMaj() {
    let resultTable = document.getElementById("resultstable");
    let headers = resultTable.rows[0].cells;

    let workerIdIndex = -1;
    let attributeIndexes = [];
    for (let i = 0; i < headers.length; i++) {
        let header = headers[i].textContent.trim();
        if (header === 'workerid') {
            workerIdIndex = i;
        } else if (header !== 'hitid' && header !== 'AssignmentId' && header !== 'Input.imageURL' && header !== 'Input.bbox' && header !== 'Input.content' && header !== 'Answer.output_data' && header !== 'amazon.image' && header !== 'Market place' && header !== 'Input.matches' && header !== 'key' && header !== 'assin_json' && header !== 'assin_juge_json') {
            attributeIndexes.push(i);
        }
    }

    if (workerIdIndex === -1 || attributeIndexes.length === 0) {
        console.error("Les colonnes 'workerid' ou attributs sont manquantes.");
        return;
    }

    let workerIdCount = {};
    for (let i = 1; i < resultTable.rows.length; i++) {
        let cells = resultTable.rows[i].cells;
        let workerId = cells[workerIdIndex].textContent.trim();
        if (!workerIdCount[workerId]) {
            workerIdCount[workerId] = {};
        }
        for (let index of attributeIndexes) {
            let attribute = headers[index].textContent.trim();
            let value = cells[index].textContent.trim();
            if (value === 'i_maj' || value === 'missing_maj') {
                if (!workerIdCount[workerId][attribute]) {
                    workerIdCount[workerId][attribute] = 0;
                }
                workerIdCount[workerId][attribute]++;
            }
        }
    }

    let topResults = {};
    for (let index of attributeIndexes) {
        let attribute = headers[index].textContent.trim();
        let counts = [];
        for (let workerId in workerIdCount) {
            if (workerIdCount[workerId][attribute]) {
                counts.push([workerId, workerIdCount[workerId][attribute]]);
            }
        }
        counts.sort((a, b) => b[1] - a[1]);
        topResults[attribute] = counts.slice(0, 10);
    }

    let resultsTopIMaj = document.getElementById("resultsTopIMaj");
    resultsTopIMaj.innerHTML = ''; // Vider le tableau précédent s'il existe

    // Ajouter la légende
    let caption = resultsTopIMaj.createCaption();
    caption.textContent = "INCORRECT MAJORITY ET MISSING MAJORITY";
	

    // Ajouter la ligne des en-têtes
    let headerRow = resultsTopIMaj.insertRow();
    headerRow.insertCell().textContent = 'Attribute';
    for (let index of attributeIndexes) {
        let headerCell = headerRow.insertCell();
        headerCell.textContent = headers[index].textContent.trim();
    }

    let totalRow = resultsTopIMaj.insertRow();
    let totalCell = totalRow.insertCell();
    totalCell.textContent = 'Total';
    for (let attribute of attributeIndexes) {
        let totalCell = totalRow.insertCell();
        let attributeTotal = topResults[headers[attribute].textContent.trim()].reduce((sum, item) => sum + item[1], 0);
        totalCell.innerHTML = `<strong>${attributeTotal}</strong>`; // Mettre le texte en gras avec HTML
    }

    for (let place = 0; place < 10; place++) {
        let row = resultsTopIMaj.insertRow();
        let placeCell = row.insertCell();
        placeCell.textContent = (place + 1) + ' Place';
        for (let attribute of attributeIndexes) {
            let cell = row.insertCell();
            let attributeName = headers[attribute].textContent.trim();
            if (topResults[attributeName][place]) {
                cell.innerHTML = `${topResults[attributeName][place][0]} (<strong>${topResults[attributeName][place][1]}</strong>)`;
            } else {
                cell.textContent = '';
            }
        }
    }
}

		//RECENSER TOP INCORRECT MINORITY + MISSING MINORITY
		function recenseTopIMin() {
    let resultTable = document.getElementById("resultstable");
    let headers = resultTable.rows[0].cells;

    let workerIdIndex = -1;
    let attributeIndexes = [];
    for (let i = 0; i < headers.length; i++) {
        let header = headers[i].textContent.trim();
        if (header === 'workerid') {
            workerIdIndex = i;
        } else if (header !== 'hitid' && header !== 'AssignmentId' && header !== 'Input.imageURL' && header !== 'Input.bbox' && header !== 'Input.content' && header !== 'Answer.output_data' && header !== 'amazon.image' && header !== 'Market place' && header !== 'Input.matches' && header !== 'key' && header !== 'assin_json' && header !== 'assin_juge_json') {
            attributeIndexes.push(i);
        }
    }

    if (workerIdIndex === -1 || attributeIndexes.length === 0) {
        console.error("Les colonnes 'workerid' ou attributs sont manquantes.");
        return;
    }

    let workerIdCount = {};
    for (let i = 1; i < resultTable.rows.length; i++) {
        let cells = resultTable.rows[i].cells;
        let workerId = cells[workerIdIndex].textContent.trim();
        if (!workerIdCount[workerId]) {
            workerIdCount[workerId] = {};
        }
        for (let index of attributeIndexes) {
            let attribute = headers[index].textContent.trim();
            let value = cells[index].textContent.trim();
            if (value === 'i_min' || value === 'missing_min') {
                if (!workerIdCount[workerId][attribute]) {
                    workerIdCount[workerId][attribute] = 0;
                }
                workerIdCount[workerId][attribute]++;
            }
        }
    }

    let topResults = {};
    for (let index of attributeIndexes) {
        let attribute = headers[index].textContent.trim();
        let counts = [];
        for (let workerId in workerIdCount) {
            if (workerIdCount[workerId][attribute]) {
                counts.push([workerId, workerIdCount[workerId][attribute]]);
            }
        }
        counts.sort((a, b) => b[1] - a[1]);
        topResults[attribute] = counts.slice(0, 10);
    }

    let resultsTopIMin = document.getElementById("resultsTopIMin");
    resultsTopIMin.innerHTML = ''; // Vider le tableau précédent s'il existe

    // Ajouter la légende
    let caption = resultsTopIMin.createCaption();
    caption.textContent = "INCORRECT MINORITY ET MISSING MINORITY";
	

    // Ajouter la ligne des en-têtes
    let headerRow = resultsTopIMin.insertRow();
    headerRow.insertCell().textContent = 'Attribute';
    for (let index of attributeIndexes) {
        let headerCell = headerRow.insertCell();
        headerCell.textContent = headers[index].textContent.trim();
    }

    let totalRow = resultsTopIMin.insertRow();
    let totalCell = totalRow.insertCell();
    totalCell.textContent = 'Total';
    for (let attribute of attributeIndexes) {
        let totalCell = totalRow.insertCell();
        let attributeTotal = topResults[headers[attribute].textContent.trim()].reduce((sum, item) => sum + item[1], 0);
        totalCell.innerHTML = `<strong>${attributeTotal}</strong>`; // Mettre le texte en gras avec HTML
    }

    for (let place = 0; place < 10; place++) {
        let row = resultsTopIMin.insertRow();
        let placeCell = row.insertCell();
        placeCell.textContent = (place + 1) + ' Place';
        for (let attribute of attributeIndexes) {
            let cell = row.insertCell();
            let attributeName = headers[attribute].textContent.trim();
            if (topResults[attributeName][place]) {
                cell.innerHTML = `${topResults[attributeName][place][0]} (<strong>${topResults[attributeName][place][1]}</strong>)`;
            } else {
                cell.textContent = '';
            }
        }
    }
}

		

		
		
		//EXECUTE ALL FONCTION C_MAJ C_MIN I_MAJ I_MIN MISSING_MAJ ET MISSING_MIN
		 function executeAllFunctions() {
            recenseTopCMaj();
            recenseTopCMin();
            recenseTopIMaj();
            recenseTopIMin();
        }
    </script>

</body>
</html>
